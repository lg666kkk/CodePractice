# 补码/原码/反码

==在计算机中参与运算的数有两大类: 无符号数和有符号数==

对于有符号数而言，用 0 表示正, 用 1 表示负

原码，反码，补码的产生过程，就是为了解决计算机做减法和引入符号位（正号和负号）的问题

## 原码

原码是机器数中最简单的一种表示形式，符号位为 0 表示正数，符号位为 1 表示负数，数值位即真值的绝对值，故原码表示又称为带符号的绝对值表示。

### 正数

正数的原码等于它本身

0010 ===>  表示十进制的 2

### 负数

1010 ===> 表示十进制的 -2 



![](E:\Typra文档\img\Snipaste_2020-11-15_21-16-06.PNG)

### 原码的缺陷

==**原码最大的问题就在于一个数加上他的相反数不等于零**==

0001 + 1001 = -2  = 1 + (-1)   ===> 有问题

## 反码

### 正数

==正数的反码等于原码==

### 负数

**负数的反码就是它的原码除符号位按位取反**

例如 -3 ，其原码是 1011，故其反码为 1100

### 反码的缺陷

0001+1110=1111 （1+（-1）= - 0 ===> 相反数问题得到解决

但是两个负数相加出问题:

​	两个负数相加 ==> -1 ( 1110 ) + -2 ( 1101 ) = -4 ( 1011 )

​	1011是反码 ===> 原码为 1100 => -4 

## 补码

### 正数

==**正数的补码等于它的原码**==

### 负数

**==负数的补码等于反码+1==**

或者 **==负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变==**

# 位运算

**==位运算总共只有5中: 与/或/异或/左移/右移==**

## 左移

左移运算 m << n 表示把m左移n位。左移n位的时候, 最左边的n位会被丢弃, 同时在最右边补上n个0。比如:

​	00001010 << 2 = 00101000

​	10001010 << 3 = 01010000

## 右移

右移运算符 m >> n 表示把 m 右移 n 位。

如果数字是一个无符号数值, 则用 0 填补最左边的 n 位。

如果数字是一个有符号数值, 则用==数字的符号位==填补最左边 n 为。即数字为一个正数, 则右移之后在最左边补n个0，若数字为负数，则右移之后在最左边补 n 个1

00001010 >> 2 = 00000010

10001010 >> 3 = 11110001

