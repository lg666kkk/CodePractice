# 正则表达式

> RegExp

> 是用来处理字符串的规则
>
> - 只能处理字符串
> - **它是一个规则：可以验证字符串是否符合某个规则(test)，也可以把字符串中符合规则的内容捕获到(exec/match...)**

```javascript
let str = "good good study , day day up!";
let reg = /\d+/
// test => 用于匹配某些规则的方法
console.log(reg.test(str)); // false

str = "2019-08-12";
console.log(reg.exec(str)); // ['2019', index:0, input:'原始字符串']
```

## 编写正则表达式

创建方式有两种:

```javascript
// 1. 字面量方式
let reg1 = /\d+/   // 两个斜杆之间包起来的都是用来描述正则规则的元字符

// 2. 基于构造函数： 有两个参数: 1)元字符字符串 2) 修饰符字符串
let reg2 = new RegExp("\\d+")  // \需要再次转义
```

### 正则表达式由两部分组成

#### 元字符

```javascript
/**常用元字符**/
// => 1. 量词元字符:设置出现的次数
* 零到多次   \d*
+ 一道多次   \d+
? 零次或一次   
{n} 出现n次(n为0或正整数)    \d{5}
{n,} 出现n到多次
{n,m} 出现n到m次(包含n和m)    \d{5,10}
 
 
// => 2. 特殊元字符: 单个或者组合代表特殊的含义
\     转义字符(普通-> 特殊 -> 普通)
.     除\n(换行符)以外的任意字符
^     以那个元字符作为开始
$     以哪一个元字符作为结束
\n    换行符
\d    0~9之间的数字
\D    非0~9之间的数字  (大写字母和小写字母含义相反)
\w    代表字母、数字、下划线任意一个字符
\W    代表非字母、数字、下划线任意一个字符
\s    一个空白字符(包括空格、制表符、换页符等等)
\S    匹配任何非空白字符
\t    一个制表符(4个空格)
\b    匹配一个单词的边界，也就是指单词和空格间的位置
x|y   x或者y中的一个字符(匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 		    	"zood" 或 "food"。)
[xyz]  x或者y或者z中的一个字符(匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 			'a'。)
[^xyz] 除了x/y/z以外的字符( '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。)
[a-z]  指定a-z范围内的任意字符  [0-9a-zA-Z_] === \w
[^a-z] 匹配任何不在指定范围内的任意字符
()     正则中的分组符号
(?:)   只匹配不捕获
(?=)   正向预查
(?!)   负向预查

// =>3. 普通元字符：代表本身含义
/zhufeng/   匹配的就是"zhufeng"
```



- `^$`

```javascript
let reg = /^\d/;
reg.test("zhufeng") // false
reg.test("2019zhu") // true
reg.test("zhu2019") // false
```

```javascript
let reg = /\d$/
reg.test("zhufeng") // false
reg.test("2019zhu") // false
reg.test("zhu2019") // true
```

```javascript
// => ^和$都不加: 字符串中包含符合规则的内容即可
let reg = /\d/
reg.test("zhufeng") // false
reg.test("2019zhu") // true
reg.test("zhu2019") // true
```

```javascript
// ^和$都加: 字符串只能是和规则一致的内容
let reg = /^\d+$/
reg.test("zhufeng") // false
reg.test("2019zhu") // false
reg.test("zhu2019") // false
```

```javascript
// 验证手机号码(11位，以1开头)
let reg = /^1\d{10}$/
```

- `\`

```javascript
let reg = /^2.3$/  => .表示除\n以外的任意字符
reg.test("2.3") // true
reg.test("2@3") // true
reg.test("23")  // false
// -----------------------------------------
let reg = /^2\.3$/  => 基于转义字符 . 只能代表点
reg.test("2.3") // true
reg.test("2@3") // false
// --------------------------------------------
let str = "\\d"  => 字符串中一个斜杠也有特殊含义
let reg = /^\d$/
reg.test(str) // false

reg = /^\\d$/
reg.test(str) // true
```

- `x|y`

```javascript
let reg = /^18|29$/
reg.test("18")   // true
reg.test("29")   // true
reg.test("189")	 // true
reg.test("129")  // true
reg.test("1829") // true
reg.test("829")  // true
reg.test("182")  // true
reg.test("82")   // true
// ------直接 x|y得到的结果很乱，一般使用这个的时候伴随着小括号进行分组，小括号会改变优先级
let reg = /^(18|29)$/;  => 分组会改变优先级
console.log(reg.test("18"));  // true
console.log(reg.test("29")); // true
console.log(reg.test("189")); // false
console.log(reg.test("129")); // false
console.log(reg.test("1829")); //false
console.log(reg.test("829")); // false
console.log(reg.test("182")); // false
console.log( reg.test("82"));  // false

```

- `[]`

```javascript
// 1. 中括号中出现的字符一般都代表本身的含义
let reg = /^[@+]+$/;  => []中的+代表本身的加号
console.log(reg.test("@@@@")); // true
console.log(reg.test("@@@@++")); // true
console.log(reg.test("++++")); // true
console.log(reg.test("@+@+")); // true
// --------------------
let reg = /^[@+]$/;
console.log(reg.test("@@@@")); // false
console.log(reg.test("@@@@++")); // false
console.log(reg.test("@+")); // false
console.log(reg.test("@")); // true
//--------------------------------
let reg = /^[\d]$/;  => /d在[]中仍然代表数字0-9
console.log(reg.test("\\")); // false
console.log(reg.test("0")); // true
console.log(reg.test("d")); // false
console.log(reg.test("1")); // true
// -----------------
// 中括号中不存在多位数
let reg = /^[18]$/
console.log(reg.test("1")); // true
console.log(reg.test("8")); // true
console.log(reg.test("18")); // false

// => reg = /^[10-49]$/  =>1或者0-4或者9
let reg = /^[10-49]$/
console.log(reg.test("1")); // true
console.log(reg.test("3")); // true
console.log(reg.test("2")); // true
console.log(reg.test("9")); // true
console.log(reg.test("0")); // true

```

  

#### 修饰符

```javascript
/**正则表达式常用修饰符：img**/
i  => (ignoreCase)忽略单词大小写匹配
m  => (multiline) 可以进行多行匹配
g  => (global) 全局匹配

/A/.test('lalla')  => false
/A/i.test('lalla') => true
```

## 常用正则

- 验证是否为有效数字

  ```javascript
  /**
    有效数字规则分析:
    	1. 可能出现+ -号，也可能不出现 (-|+)? 或者 [+-]?
    	2. 只有一位: 0-9都可以 (\d|([1-9]\d+))
    	3. 多位首位不为0
    	4. 小数部分可能有可能没有，一旦有后面必须有小数点+数字
  **/
  let reg = /^(\+|\-)?(\d|([1-9]\d+))(\.\d+)?$/;  // 使用()记得转义+/-
  let reg1 = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/; 
  console.log(reg.test("3.234")); // true
  console.log(reg1.test("09")); // false
  console.log(reg.test("10")); // true
  ```

- 验证密码

  ```javascript
  // 数字,字母,下划线  6~16位
  /**
  // 不使用正则
  function chechPassword (val) {
      if (val.length <6 || val.length > 16) {
          alert("长度必须在6~16位之间！")
          return
      }
      let area = ['a', 'b', 'c', ... ,'_'] // 包含数字,字母,下划线
      for (let i=0; i<val.length; i++) {
          let char = val[i]
          if (!area.includes(char)) {
              alert("格式不正确!")
              return 
          }
      }
  }
  **/
  let reg = /^\w{6,16}$/;  // 使用正则
  console.log(reg.test("3.234")); // false
  console.log(reg.test("09ddddee_")); // true
  console.log(reg.test("102222")); // true
  ```

- 验证真实姓名

  ```javascript
  /*
  * 1. 汉字: [\u4E00-\u9FA5]
  * 2. 名字长度 2-10位
  * 3. 可能有汉译名: 尼古拉斯·赵四
  */
  let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10}){0,4}$/;  
  console.log(reg.test("你挂了·得到的·得到的")); // true
  console.log(reg.test("你哈")); // true
  console.log(reg.test("·得到的")); // false
  ```

- 验证邮箱

  ```javascript
  //邮箱名字可以由 数字 字母 下划线 - . 这五部分构成，但是-/.不能连续出现并且不能作为开始字符
  /*	
  	=> \w+((-\w+)|(\.\w+))*
  	1. 开头必须是数字字母下划线(1到多位)
  	2. 还可以是 -数字字母下划线 或者 .数字字母下划线(0到多位)
  */
  /*
  	=> @[A-Za-z0-9]+
  	@后面紧跟只能是 数字 字母
  */
  /*
  	=> ((\.|-)[A-Za-z0-9]+)*
  	匹配@xxx.com.cn中的.com之类格式的
  */
  /*
  	=> \.[A-Za-z0-9]+
  	匹配最后的域名(.com/.cn/.vip/.org/.edu/.net等等)
  */
  let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;  
  ```

- 身份证号码

  ```javascript
  // 第二代身份证18位/最后一位可能是X/前六位是你所在的省市县/中间8位是出生年月日/最后一位是X或数字/倒数第二位偶数是女奇数是男/其余的是经过算法算出来的
  // => 小括号第二个作用: 分组捕获(第一个作用:改变优先级)
  let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
  reg.exec("620422199903110216")
  // 捕获的结果是一个数组
  ```

## 创建正则的两种方式区别

  ```javascript
// 情况1
let reg = /\d+/g
reg = new RegExp("\\d+", "g") // 构造函数方式需要将斜杆转义

// 情况2：正则表达式中的部分类容是变量存储的值
// => 2.1 字面量创建方式不能在正则表达式中拼接变量
let type = "zhufeng"
reg = /^@"+type+"@$/ => 两个斜杆之间包起来的都是元字符
// 以@开始，以@结束，“出现多次,e出现多次
reg.test('@"""typeeee"@') // true
// => 2.2 使用构造函数方式创建的可以使用变量
reg = new RegExp("^@"+type+"@$")
reg.test("@zhufeng@") // true
  ```

## 正则表达式的捕获

- 正则RegExp.prototype上的方法
  - exec()
  - test()
- 字符串String.prototype支持正则表达式的处理方法
  - replace()
  - match()
  - splite()
  - search()
  - ....

```javascript
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /^\d+$/
// => 实现正则捕获的前提是:当前正则要和字符串匹配
console.log(reg.test(str)); // false
console.log(reg.exec(str)); // null
```

```javascript
/*
基于exec实现正则捕获:
	1. 捕获到的结果是null或者是一个数组
	2. 数组第一项 当前捕获到的内容
	3. 其余项: 对应小分组单独捕获到的内容
	4. index:捕获到的结果在字符串中出现的起始索引
	5. input:原始字符串
	6. 每执行一次exec只能捕获到一个符合正则规则的结果，但是默认情况下，我们执行多次获取的结果永远都是第一次捕获到的结果，其余的捕获不到(正则捕获的懒惰性)
*/
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/
console.log(reg.exec(str)); 
// ["2019", index: 7, input: "zhufeng2019yangfan2020qihang2021", groups: undefined]
```

```javascript
// 正则懒惰性的原因: 默认情况下lastIndex的值不会被改变，每一次都是从0开始查找
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/
// reg.lastIndex: 当前正则下一次匹配的其实索引位置
console.log(reg.lastIndex); // => 0 下一次匹配捕获是从str索引为0的位置开始找
console.log(reg.exec(str)); // 从0开始捕获
console.log(reg.lastIndex); // => 0 第一次匹配捕获完成后任然是0 => 导致了懒惰性
console.log(reg.exec(str)); // 任然从0开始捕获
```

```javascript
// 加修饰符g => 解决懒惰性
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/g  // => 加g
console.log(reg.lastIndex); // => 0 
console.log(reg.exec(str));
// ["2019", index: 7, input: "zhufeng2019yangfan2020qihang2021", groups: undefined]
console.log(reg.lastIndex); // => 11
console.log(reg.exec(str)); 
// ["2020", index: 18, input: "zhufeng2019yangfan2020qihang2021", groups: undefined]
console.log(reg.lastIndex); // => 22
console.log(reg.exec(str)); 
//["2021", index: 28, input: "zhufeng2019yangfan2020qihang2021", groups: undefined]
console.log(reg.lastIndex); // => 32 
console.log(reg.exec(str)); // null
console.log(reg.lastIndex); // => 0
.....
```

```javascript
// 注意:
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/g
if (reg.test(str)) {
    // 只有正则和字符串匹配我们才捕获
    // reg.test(str): 全局匹配模式下,test也能改变lastIndex值
    console.log(reg.lastIndex); // 11
    console.log(reg.exec(str)); // ["2020"...]
}
```

```javascript
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/g
// 要求编写一个方法execAll,执行一次可以把所有的匹配结果捕获到
~function () {
    function execAll (str = "") {
        // 验证当前正则是否有修饰符g(不加g可能会导致死循环)
        if (!this.globl) {
            return this.exec(str)
        }
        // => str表示要匹配的字符串
        // => this: RegExp的实例(当前操作的正则)
        let result = [],
            res = this.exec(str)
        while (res) { // 只要捕获的内容不为null，继续捕获
            result.push(res[0])
            res = this.exec(str)
        }
        return result.length === 0 ? null : result
    }
    RegExp.prototype.execAll = execAll
}()
console.log(reg.execAll(str)); // ["2019", "2020", "2021"]
// ------------------------------
上面实现的方法相当于字符串的match方法
let str = "zhufeng2019yangfan2020qihang2021"
let reg = /\d+/g  // => 要加g，不然只会返回第一个
console.log(str.match(reg)); // ["2019", "2020", "2021"]
```

