## 1111.有效括号的嵌套深度

### 题目描述

**有效括号字符串** 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「**有效括号字符串**」部分。

**嵌套深度** `depth` 定义：即有效括号字符串嵌套的层数，`depth(A)` 表示有效括号字符串 `A` 的嵌套深度。详情参见题末「**嵌套深度**」部分。

有效括号字符串类型与对应的嵌套深度计算方法如下图所示：

![](E:/GitResort/CodePractice/笔记/Leetcode/img/Snipaste_2020-04-01_20-06-39.PNG)

给你一个「有效括号字符串」 `seq`，请你将其分成两个不相交的有效括号字符串，`A` 和 `B`，并使这两个字符串的深度最小

- 不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。

- A 或 B 中的元素在原字符串中可以不连续。

- A.length + B.length = seq.length

- 深度最小：max(depth(A), depth(B)) 的可能取值最小

划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：

- `answer[i] = 0`，`seq[i]` 分给 `A` 。

- `answer[i] = 1`，`seq[i]` 分给 `B` 。

如果存在多个满足要求的答案，只需返回其中任意 一个 即可

提示：`1 < seq.size <= 10000`

### 有效括号字符串
仅由 "(" 和 ")" 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。

下述几种情况同样属于有效括号字符串：

  1. 空字符串
  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串
  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串
### 嵌套深度
类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：

  1. s 为空时，depth("") = 0
  2. s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串
  3. s 为嵌套情况，depth("(" + A + ")") = 1 + depth(A)，其中 A 是有效括号字符串

例如：""，"()()"，和 "()(()())" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 ")(" 和 "(()" 都不是有效括号字符串。

### 示例

#### 示例1

```javascript
输入：seq = "(()())"
输出：[0,1,1,1,1,0]
```

#### 示例2

```javascript
输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
解释：本示例答案不唯一。
按此输出 A = "()()", B = "()()", max(depth(A), depth(B)) = 1，它们的深度最小。
像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = "()()()", B = "()", max(depth(A), depth(B)) = 1
```

### 解题思路

#### 用栈进行括号匹配

1. 由题目可以知道：

- 嵌套」才会产生「深度」，所以题目的定义是嵌套深度，极端例子 1：`()()()()`，这个字符串的「嵌套深度」为 11。极端例子 2：`(((())))` 这个字符串的「嵌套深度」为 4。而这个深度恰好与在匹配过程中，栈的最大高度是一致的；

- 在「有效括号字符串」连接的时候，depth(A + B) = max(depth(A), depth(B)) 的意思是大吃小，即在两个「有效括号字符串」连接的时候，整体深度取决于部分「有效括号字符串」的深度，这一点特别像在二叉树中的计算二叉树的高度
- 其实仔细观察就会发现，这个「嵌套深度」就是输入字符串，**使用栈完成括号匹配，栈中最多连续出现的左括号 ( 的个数**。
- 而题目要求我们把输入的整体有效字符串做一个重组，要求是只拆成两个部分 A 和 B ，每个字符要么分到 A 要么分到 B，分到 A 标记为 0，分到 B 标记为 1。而每个部分的字符又要保持在输入字符串中的顺序不变。因此输出是一个与原始字符串等长的整数数组，这个整数数组里只有 0 和 1。

2. 例如示例1

- 输入：seq = "(()())"，嵌套深度为 2，最多连续出现了 2 个左括号。现在要拆分以后再重组，其实思路就有了，把这两个连续出现的左括号分到不同组即可。

  输出：[0, 1, 1, 1, 1, 0] 对应了输入字符串的每个字符对应的组号，0 分到 A 组，1 分到 B 组

3. 对于示例1(**重组字符串的顺序保持了在输入字符串中的相对顺序**)

   ![](E:/GitResort/CodePractice/笔记/Leetcode/img/111-1.PNG)

   标记为 0 的组的「嵌套深度」是 1；标记为 1 的组的「嵌套深度」是 1，因此总的「嵌套深度」就是 1。

   从这个示例中我们知道，重组以后的嵌套深度是原始嵌套深度的一半（不能整除的时候上取整）。

   - 如果原始嵌套深度是偶数，例如 6，重组的嵌套深度 = 3；
   - 如果原始嵌套深度是奇数，例如 7，重组的嵌套深度 = 4

4. 示例2

![](E:/GitResort/CodePractice/笔记/Leetcode/img/222-2.PNG)

说明：结果不唯一，但一定要保证连续的左括号 (( 不被分在同一组，具体来说，就是完成「括号匹配」问题使用的栈里，同时出现的左括号，不能在同一个分组里，这样就不会增加嵌套的深度。

5. 思路分析

- 根据 depth(A + B) = max(depth(A), depth(B)) 这个定义，整体的「嵌套深度」取决于子序列的「嵌套深度」的最大者；
- 要使得 max(depth(A), depth(B)) 的可能取值最小，分析示例的时候提到，这很像一棵二叉树，要使得二叉树的深度最小，那么就需要该二叉树平衡，一个可行的做法是：把栈中连续出现的左括号 ( 根据奇偶性分到不同的组，右括号随与之匹配左括号的组号；
- 如果出现 () 这种子序列，即左括号后面连着出现了右括号，其实分在那一组都是没有关系的，因为它的存在不会使得「嵌套深度」更深。


```javascript
var maxDepthAfterSplit = function(seq) {
    let dep = 0;// 嵌套深度，栈的当前高度
    return seq.split("").map((value, index) => {
        if (value === '(') {
            ++dep;// 遍历到左括号，连续括号个数加 1，
            return dep % 2;// % 2 也可以写成 & 1，为了保证语义清楚，写 % 2
        } else {
             // 遍历到右括号，与当前栈顶左括号分在一组，因此先取模，再 --
            let ans = dep % 2;
            --dep;
            return ans;
        }
    });
};
//时间复杂度：O(n)O(n)，其中 nn 为字符串的长度。我们只需要遍历括号字符串一次。
//空间复杂度：O(1)O(1)。除答案数组外，我们只需要常数个变量。
```

> 核心思想就是：连续的 `(`会造成嵌套深度的增加，因此对于这种要把他们分到不同的组中。而连续的标准不仅仅是原始字符串中的左右相邻，应该还包括中间成对的 `（）`消除后的连续。

#### 方法2

要让A和B的最大深度最小，关键就是，AB你俩的深度谁都别涨太快。别A的深度都到10了，B还0深度呢。所以很简单，涨深度的时候，谁比较浅，我就给谁涨。降的时候，谁比较深，我就给谁降。

啥叫“涨深度”呢？那就是`'('`啊，来一个左括号，那深度就涨一格，所以AB谁浅就给谁涨。深度一样的话呢，就随便给涨一个。

涨完了你得降啊，啥叫“降深度”呢？那就是右括号啊，右括号来了谁深先降谁。

```javascript
var maxDepthAfterSplit = function(seq) {
    let ans = []
    let a=b=0 // 深度
    seq.split("").map((value, index) => {
        if (value == '(') {
            if (a <= b) {
                a += 1
                ans.push(0)
            } else {
                b+= 1
                ans.push(1)
            }  
        } else if (value == ')') {
            if (a>b){
                a-=1
                ans.push(0)
            } else {
                b-=1
                ans.push(1)
            }
        }
    })
    return ans
};
```

