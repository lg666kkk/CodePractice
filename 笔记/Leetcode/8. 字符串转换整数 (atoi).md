## 字符串转换整数

### 题目描述

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

- 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
- 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
- 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 

提示：

- 本题中的空白字符只包括空格字符·`' '` 。
- 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

### 示例

#### 示例1

```javascript
输入: "42"
输出: 42
```

#### 示例2

```javascript
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

#### 示例3

```javascript
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

#### 示例4

```javascript
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

#### 示例5

```javascript
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 
```

### 解题思路

#### 方法一

1. 官方的主要规则可以概括为：

   - 无视开头空格
   - 返回有符号整数
   - 无视整数部分后的字符
   - 范围在`32`位内（含）
   - 其他情况返回`0`

   这个转换规则就是JS中的`parseInt()`这一API的转换规则

2. 逻辑梳理

   - **parseInt(string, radix)**这一API使用

     +  parseInt(string, radix)将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。

     + 参数string : 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  `ToString `抽象操作)。字符串开头的空白符将会被忽略。

     + 参数radix(可选)：从 `2` 到 `36`，代表该进位系统的数字。例如说指定 `10` 就等于指定十进位。请注意，通常预设值**不**是 `10` 进位！

     + 返回值：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。

     + 注意：`radix`参数为n 将会把第一个参数看作是一个数的n进制表示，而返回的值则是十进制的。例如：

       ```javascript
       parseInt('123', 5) // 将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38
       ```

     + 在使用`parseInt(string, radix)`这一API时，如果不传入`radix`参数，会有两种特殊情况:

       + 如果字符串 `string` 以"0x"或者"0X"开头, 则基数是`16` (**16进制**)
       + 如果字符串 `string` 以"0"开头, 基数是`8`（**八进制**）或者`10`（**十进制**），那么具体是哪个基数，取决与ECMAScript的版本
       + 所以，通常建议在使用`parseInt()`这一API时，都明确给出期望的进制数

   - 对比题意，会发现：

     + 无视开头空格（满足）
     + 返回有符号整数（满足）
     + 无视整数部分后的字符（满足）
     + 范围在`32`位内（含）（**不满足**）
     + 其他情况返回`0`（**不满足**）

   - **范围在32位内（含）**-- 解决方法如下：
   
     ```javascript
     if (number < Math.pow(-2, 31) || number > Math.pow(2, 31) - 1) {
         return number < Math.pow(-2, 31) ? Math.pow(-2, 31) : Math.pow(2, 31) - 1;
     }
     ```
   
   - **其他情况返回0**  --- 解决方法如下：
   
     API的返回值如果是NaN，则说明无法正常转换，所以只需将返回值和NaN进行比较即可。
   
     注意，NaN和NaN并不全等，所以各位JSer不能使用全等操作符（===），而该使用`isNaN()`函数来比较
   
     ```javascript
     if(isNaN(number)) {
         return 0;
     } 
     ```
   
3. 代码实现

   ```javascript
   /**
    * @param {string} str
    * @return {number}
    */
   var myAtoi = function(str) {
       const number = parseInt(str, '10')
       if (number < Math.pow(-2,31) || number > Math.pow(2,31)-1) {
           return number < Math.pow(-2, 31) ? Math.pow(-2, 31) :  (Math.pow(2,31)-1)
       }
       if (isNaN(number)) {
           return 0
       }
       return number
   };
   ```

#### 方法二

巧用正则表达式

1. 正则表达式

2. 常用正则规则

   - 正则表达式的定位符

     | 字符 | 描述                                                         |
     | :--: | :----------------------------------------------------------- |
     |  ^   | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配 |
     |  $   | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
     |  \b  | 匹配一个单词边界，即字与空格间的位置                         |
     |  \B  | 非单词边界匹配                                               |

   - 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种

     | 字符  | 描述                                                         |
     | ----- | ------------------------------------------------------------ |
     | *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,} |
     | +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,} |
     | ？    | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1} |
     | {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o |
     | {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*' |
     | {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格 |

   - 以下正则表达式匹配一个正整数，**[1-9]**设置第一个数字不是 0，**[0-9]\*** 表示任意多个数字

     ```javascript
     /[1-9][0-9]*/
     ```

   - \\d  -- 匹配数字

     ```javascript
     例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$
     ```

   - ***、+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配**

   - 特殊字符

     | 字符 | 描述                                                         |
     | ---- | ------------------------------------------------------------ |
     | \|   | 指明两项之间的一个选择。要匹配                               |
     | {    | 标记限定符表达式的开始。要匹配 {，请使用 \\{                 |
     | ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用\ \( 和 \\) |
     | .    | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\.      |

   - 正则表达式修饰符

     - i -- 不区分大小写

       ```javascript
        /abc/i 可以匹配 abc、aBC、Abc 
       ```

     - g -- 全局(global)匹配 

       ```javascript
       如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回
       如果带g，则字符串从左到右，找到每个符合条件的都记录下来，知道字符串结尾位置
       例如: 
       var str = 'aaaaaaaa'
       var reg1 = /a/;  str.match(reg1)  // 结果为：["a", index: 0, input: "aaaaaaaa"]
       var reg2 = /a/g; str.match(reg2)  // 结果为：["a", "a", "a", "a", "a", "a", "a", "a"]
       ```

     - m -- 多(more)行匹配

       ```javascript
       若存在换行\n并且有开始^或结束$符的情况下，和g一起使用实现全局匹配,
       因为存在换行时默认会把换行符作为一个字符任务匹配字符串是个单行，
       g只匹配第一行，添加m之后实现多行，每个换行符之后就是开始
       var str = "abcggab\nabcoab";
       var preg1 = /^abc/gm;  str.match(preg1)  // 结果为：["abc", "abc"]
       var preg2 = /ab$/gm;   str.match(preg2)  // 结果为：["ab", "ab"]
       ```

     - s -- 特殊字符圆点( . )中包含换行符

       ```javascript
       默认的圆点 . 是 匹配除换行符 \n 之外的任何单字符，加上s之后, . 中包含换行符
       $str = "abggab\nacbs";
       $preg = "/b./s";
       preg_match_all($preg, $str,$matchs);
       print_r($matchs);//Array ( [0] => Array ( [0] => bg [1] => b [2] => bs ) ) 
       ```

   - match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

     - 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置

     - 如果没有找到任何匹配的文本， match() 将返回 `null`。否则，它将返回一个`数组`，其中存放了与它找到的匹配文本有关的信息

3. 代码实现

   ```javascript
   /**
    * @param {string} str
    * @return {number}
    */
   var myAtoi = function(str) {
      let res = str.trim().match(/^(\-|\+)?\d+/g)
       return res ? Math.max(Math.min(Number(res[0]),2**31-1),-(2**31)) : 0
   };
   ```

   