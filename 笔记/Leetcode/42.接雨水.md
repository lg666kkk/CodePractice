# 42.接雨水

## 题目描述

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水

![](E:\GitResort\CodePractice\笔记\img\Snipaste_2020-04-04_18-03-01.PNG)

## 示例

```javascript
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
## 解题思路

### 暴力法

对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值

#### 思路梳理

以示例中下标为5(下标从0开始)的元素为例：

1. 找到下标为5的左边高度最高的 max_left
2. 找到下标为5的右边高度最高的 max_right
3. 取min(max_left, max_right)
4. 再利用min(max_left, max_right) - 下标为5的位置上的元素值得到的就是下标为5的位置的积水数目

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let sum = 0
    let h = height.length
    for (let i=1; i<h; i++) {
        let max_left = 0
        let max_right = 0
        // 内部循环的 j 是从 i 开始的，即是求包含当前元素在内的左右两边最大值的较小者
        // 这点保证了不会出现负数的操作
        for (let j=i; j>=0; j--) {
            max_left = Math.max(max_left, height[j])
        }
        // k与j同理
        for (let k=i; k<h; k++) {
            max_right = Math.max(max_right, height[k])
        }
        sum += Math.min(max_left, max_right) - height[i]
    }
    return sum
};
// 时间复杂度： O(n²) --- 数组中的每个元素都需要向左向右扫描。
// 空间复杂度 O(1) 的额外空间。
```

### 动态编程

#### 动态编程思想：

动态编程分为如下几步:

- 将复杂问题拆分成多个较简单的子问题
- 对每个子问题只计算一次，然后使用数据结构（数组，字典等）在内存中存储计算结果
- 子问题的计算结果按照一定规则进行排序（如，基于输入参数）
- 当需要再次运算子问题时直接使用已存储的计算结果而非再次运算以提升求解性能

#### 解题思路

与暴力方法不同之处在于，在暴力方法中，为了找最大值每个位置都要向左向右扫描一次

但是我们可以提前存储这个最大值，所以我们可以使用动态编程来解决

#### 代码实现

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let sum = 0
    let max_left = []
    let max_right = []
    // 获取每个元素最左边的最大值
    max_left[0] = height[0]
    for (let i=1; i<height.length-1; i++) {
        max_left[i] = Math.max(max_left[i-1], height[i])
    }
    // 获取每个元素最右边的最大值
    max_right[height.length-1] = height[height.length-1]
    for (let j=height.length-2; j>=1; j--) {
        max_right[j] = Math.max(max_right[j+1], height[j])
    }
    
    for (let i=1; i<height.length-1; i++) {
        sum += Math.min(max_left[i], max_right[i]) - height[i]
    }
    return sum
};
/**
	时间复杂度：O(n)
	   -- 存储最大高度数组，需要两次遍历，每次 O(n)
	   -- 最终使用存储的数据更新sum ，O(n)
	 空间复杂度 需要 O(n) 额外空间
	   -- 额外的 O(n)空间用来放置max_left 和 max_right数组
*/
```



